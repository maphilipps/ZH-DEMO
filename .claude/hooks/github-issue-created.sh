#!/bin/bash

# Building Lane GitHub Issue Integration Hook
# Triggered when new GitHub issues are created from Planning Lane

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CLAUDE_DIR="$(dirname "$SCRIPT_DIR")"
BUILDING_DIR="$CLAUDE_DIR/lanes/building"
LOG_FILE="$CLAUDE_DIR/github-integration.log"

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Logging function
log_github() {
    local level="$1"
    local message="$2"
    local timestamp=$(date -Iseconds)
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
}

# Function to process GitHub issue for Building Lane
process_github_issue() {
    local issue_number="$1"
    
    echo -e "${BLUE}ðŸ”— Processing GitHub Issue #$issue_number for Building Lane${NC}"
    
    if ! command -v gh &> /dev/null; then
        echo -e "${YELLOW}âš ï¸  GitHub CLI not available, skipping issue processing${NC}"
        return 1
    fi
    
    # Get issue details
    local issue_data=$(gh issue view "$issue_number" --json title,body,labels,assignees,url)
    local issue_title=$(echo "$issue_data" | jq -r '.title')
    local issue_url=$(echo "$issue_data" | jq -r '.url')
    local issue_body=$(echo "$issue_data" | jq -r '.body')
    local labels=$(echo "$issue_data" | jq -r '.labels[].name' | tr '\n' ',' | sed 's/,$//')
    
    # Check if this is a planning-lane issue
    if [[ "$labels" =~ "planning-lane" ]]; then
        echo -e "${GREEN}âœ… Planning Lane issue detected${NC}"
        
        # Create Building Lane task file
        local task_file="$BUILDING_DIR/github-issue-$issue_number.md"
        
        cat > "$task_file" <<EOF
# Building Lane Task: $issue_title

**GitHub Issue**: $issue_url
**Issue Number**: #$issue_number
**Labels**: $labels
**Status**: Ready for Implementation
**Created**: $(date -Iseconds)

## Issue Description

$issue_body

## Building Lane Implementation Checklist

- [ ] Issue analyzed and understood
- [ ] Requirements extracted from Planning Lane output
- [ ] Architecture reviewed and approved
- [ ] Implementation started
- [ ] Tests written and passing
- [ ] Documentation updated
- [ ] Swiss compliance validated
- [ ] GPZH demo requirements met
- [ ] Learnings captured in .claude/learnings.json
- [ ] PR created and linked to issue

## Compounding Engineering Notes

Apply lessons from previous implementations:
- Check .claude/learnings.json for relevant patterns
- Follow established architectural decisions from CLAUDE.md
- Ensure Swiss compliance standards (eCH-0059, CH-DSG)
- Maintain GPZH demo functionality (4 required forms)
- Use established SDC component patterns

## Next Steps

1. Review GitHub issue details: $issue_url
2. Extract implementation requirements
3. Create feature branch: \`git checkout -b feature/issue-$issue_number\`
4. Implement according to Planning Lane specifications
5. Create comprehensive tests
6. Update documentation and learnings
7. Create PR linking back to issue

## Links

- **GitHub Issue**: $issue_url
- **Planning Lane Output**: Referenced in issue
- **Building Lane Directory**: $BUILDING_DIR
- **Learnings**: .claude/learnings.json

EOF

        echo -e "${GREEN}âœ… Building Lane task created: $task_file${NC}"
        log_github "SUCCESS" "Created building task for issue #$issue_number"
        
        # Update issue with building lane acknowledgment
        gh issue comment "$issue_number" --body "ðŸ”§ **Building Lane Activated**

This issue has been processed by the Building Lane automation.

**Task File**: \`.claude/lanes/building/github-issue-$issue_number.md\`
**Status**: Ready for implementation
**Next**: Feature branch creation and development

The Building Lane will:
1. âœ… Create comprehensive implementation plan
2. âœ… Apply compounding engineering learnings  
3. âœ… Ensure Swiss compliance standards
4. âœ… Validate GPZH demo requirements
5. âœ… Create tests and documentation
6. âœ… Link PR back to this issue

**Auto-generated by Building Lane** ðŸ¤–"

        log_github "INFO" "Added building lane comment to issue #$issue_number"
        
        return 0
    else
        echo -e "${YELLOW}âš ï¸  Issue #$issue_number not tagged as planning-lane, skipping${NC}"
        return 1
    fi
}

# Function to check for new planning-lane issues
check_new_issues() {
    echo -e "${BLUE}ðŸ” Checking for new planning-lane issues${NC}"
    
    if ! command -v gh &> /dev/null; then
        echo -e "${YELLOW}âš ï¸  GitHub CLI not available${NC}"
        return 1
    fi
    
    # Get recent issues with planning-lane label
    local recent_issues=$(gh issue list --label "planning-lane" --state "open" --limit 10 --json number,title,createdAt)
    
    if [[ "$recent_issues" == "[]" ]]; then
        echo -e "${YELLOW}ðŸ“­ No recent planning-lane issues found${NC}"
        return 0
    fi
    
    echo "$recent_issues" | jq -r '.[] | @base64' | while read -r encoded_issue; do
        local issue_data=$(echo "$encoded_issue" | base64 --decode)
        local issue_number=$(echo "$issue_data" | jq -r '.number')
        local issue_title=$(echo "$issue_data" | jq -r '.title')
        local created_at=$(echo "$issue_data" | jq -r '.createdAt')
        
        # Check if we already have a task file for this issue
        local task_file="$BUILDING_DIR/github-issue-$issue_number.md"
        
        if [[ ! -f "$task_file" ]]; then
            echo -e "${GREEN}ðŸ†• New issue found: #$issue_number - $issue_title${NC}"
            process_github_issue "$issue_number"
        else
            echo -e "${BLUE}â„¹ï¸  Issue #$issue_number already processed${NC}"
        fi
    done
}

# Main execution
main() {
    echo -e "${BLUE}ðŸ¤– Building Lane GitHub Integration${NC}"
    echo "$(date -Iseconds) - GitHub integration hook started" >> "$LOG_FILE"
    
    case "${1:-check}" in
        "check"|"")
            check_new_issues
            ;;
        "process")
            if [[ -n "${2:-}" ]]; then
                process_github_issue "$2"
            else
                echo "Usage: $0 process <issue_number>"
                exit 1
            fi
            ;;
        "help"|"-h"|"--help")
            echo "Usage: $0 [check|process ISSUE_NUMBER|help]"
            echo ""
            echo "Commands:"
            echo "  check             - Check for new planning-lane issues (default)"
            echo "  process NUMBER    - Process specific issue number"
            echo "  help             - Show this help"
            ;;
        *)
            echo "Unknown command: $1"
            echo "Use '$0 help' for usage information"
            exit 1
            ;;
    esac
    
    log_github "INFO" "GitHub integration hook completed"
}

# Execute main function
main "$@"