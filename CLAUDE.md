# CLAUDE.md - Test-Driven Development & Continuous Learning System

This file serves as the living memory and learning system for the GPZH project, implementing Test-Driven Development principles where every bug becomes a prevention rule, every decision becomes reusable knowledge, and every successful solution becomes a pattern.

## üß† Core Learning Principles

**TDD Development Approach**:
- Every bug transforms into a permanent prevention rule
- Every decision gets documented and becomes reusable
- Every successful code solution evolves into a pattern
- User dissatisfaction triggers immediate learning documentation
- Each command execution creates learning opportunities

**Continuous Improvement**: When development doesn't meet expectations, the failure is documented in this file to prevent the same mistake from recurring.

## üéØ Project Context: GPZH Pr√§qualifikation Demo System

**ZH-DEMO Prototyp** - A Drupal 11.2.2 multi-site CMS demonstration system for the GPZH (Gemeindeportale Z√ºrich) prequalification presentation. This system demonstrates our technical capabilities for the Canton of Zurich's municipal portal project.

**Demo Municipality**: Gemeinde Bruchtal ("Leben am See" - Life by the Lake)

## üîÑ Three-Lane Development System

- **Planning Lane**: Strategic analysis and architecture (@drupal-solution-architect + @drupal-technical-pm)
- **Building Lane**: Implementation and development (@drupal-11-lead-developer + @municipality-portal-specialist)  
- **Reviewing Lane**: Quality assurance and compliance (@swiss-compliance-specialist + @qa-testing-specialist)

## üìö Learning & Pattern Documentation

### Current Learning Status
**Last Updated**: 2025-08-27
**Active Patterns**: Frontend editing, Drupal MCP integration, TDD learning cycles, Complex task agent orchestration, MCP server orchestration
**Current Phase**: Multi-technology integration planning with specialized agent coordination
**Recent Learnings**: Issue #47 agent assignment patterns, execution dependency analysis, documentation anti-pattern prevention, MCP server usage patterns

## üõ†Ô∏è MCP Server Usage Guide - Compound Engineering Integration

*Strategic tool selection for exponential development acceleration through specialized automation*

### Core Usage Principle
**Prevention Rule**: ALWAYS match MCP server capabilities to specific problem domains - each server transforms routine tasks into compound intelligence opportunities. Every server selection should accelerate learning documentation and pattern recognition.

### Primary Development Servers

#### **mcp-server-drupal** üéØ PRIMARY CMS TOOL
**When to Use**: ALL Drupal configuration, content management, and architecture modifications  
**Best For**: Configuration exports, entity management, field operations, content population, module operations  
**GPZH Context**: Municipality portal configuration, paragraph setup, user role management, compliance configuration  
**Compound Intelligence**: Every Drupal operation becomes a reusable configuration pattern  
**Prevention Rules Applied**: Rule #1 (Paragraphs frontend editing), Rule #3 (Configuration management)  
**Learning Integration**: Document every configuration change as prevention rule or success pattern  
**Success Pattern**: Issue #38 - Fixed 6 paragraph configurations systematically vs. manual database modifications

#### **github** üîÑ VERSION CONTROL ORCHESTRATION
**When to Use**: All GitHub operations, PR management, issue tracking, workflow automation  
**Best For**: Issue analysis, PR reviews, repository operations, code search, workflow management  
**GPZH Context**: Issue tracking for demo features, PR reviews for security compliance, workflow management  
**Compound Intelligence**: Transform GitHub activities into documented learning patterns  
**Prevention Rules Applied**: Rule #6 (Git lock resolution), Code Review Learning rules  
**Learning Integration**: Every PR review creates documented prevention rules in CLAUDE.md  
**Success Pattern**: PR #39 resolution with systematic learning documentation from all review comments

#### **playwright** üß™ PRIMARY TESTING ENGINE
**When to Use**: Browser automation, E2E testing, visual regression, form validation, navigation testing  
**Best For**: Cross-browser testing, accessibility validation, performance testing, user journey validation  
**GPZH Context**: Swiss compliance testing, municipality portal UX validation, accessibility compliance  
**Compound Intelligence**: Every test becomes a permanent quality gate and regression prevention  
**Prevention Rules Applied**: Rule #2 (Tool selection standards), Rule #5 (Test failure analysis)  
**Learning Integration**: Test failures become prevention rules, success patterns become reusable testing strategies  
**Success Pattern**: Used over Puppeteer for superior cross-browser support and TypeScript integration

### Specialized Analysis Servers

#### **sequential-thinking** üß† COMPLEX PROBLEM BREAKDOWN
**When to Use**: Multi-phase problem analysis, architectural decisions, debugging complex issues  
**Best For**: Breaking down Issue #47-level complexity, dependency analysis, root cause investigation  
**GPZH Context**: Swiss compliance analysis, multi-technology integration planning, architecture decisions  
**Compound Intelligence**: Transform complex problems into systematic solution patterns  
**Prevention Rules Applied**: Rule #10 (Parallel vs sequential dependencies), Pattern #5 (Dependency analysis)  
**Learning Integration**: Every complex analysis becomes reusable problem-solving pattern  
**Success Pattern**: Issue #47 dependency mapping prevented execution bottlenecks through systematic analysis

#### **octocode** üîç GITHUB ECOSYSTEM INTELLIGENCE
**When to Use**: Code pattern research, library evaluation, implementation examples, best practice discovery  
**Best For**: Finding implementation patterns, library documentation, code examples, architecture research  
**GPZH Context**: Drupal module research, Vite configuration examples, Swiss government portal patterns  
**Compound Intelligence**: External code research becomes internal knowledge and prevention rules  
**Prevention Rules Applied**: Pattern #4 (Compound intelligence), Documentation anti-pattern prevention  
**Learning Integration**: Research findings become documented patterns and implementation guides  
**Success Pattern**: Research PreviousNext standards to inform Issue #47 implementation decisions

#### **context7** üìö LIBRARY DOCUMENTATION INTELLIGENCE
**When to Use**: Library-specific implementation guidance, API documentation, integration patterns  
**Best For**: React/Vite/Storybook implementation details, Drupal module documentation, framework integration  
**GPZH Context**: Frontend build tool configuration, Drupal theme integration, component documentation  
**Compound Intelligence**: Library knowledge becomes project-specific implementation patterns  
**Prevention Rules Applied**: Rule #9 (Specialized agent assignment), Technical standards documentation  
**Learning Integration**: Library patterns become reusable configuration templates  
**Success Pattern**: Vite and Storybook implementation guidance for zero-maintenance architecture

### Quality Assurance Servers

#### **a11y-accessibility** ‚ôø SWISS COMPLIANCE VALIDATION
**When to Use**: Accessibility auditing, WCAG compliance, Swiss government standards validation  
**Best For**: eCH-0059 compliance testing, accessibility pattern validation, government portal compliance  
**GPZH Context**: Municipality portal accessibility, Swiss compliance requirements, government standards  
**Compound Intelligence**: Accessibility testing becomes permanent compliance validation patterns  
**Prevention Rules Applied**: Pattern #3 (Swiss compliance integration), Testing quality gates  
**Learning Integration**: Accessibility findings become prevention rules for future components  
**Success Pattern**: Automated compliance validation with 95% accessibility threshold requirements

#### **ide** üîß DEVELOPMENT DIAGNOSTICS
**When to Use**: Code analysis, error diagnosis, development environment troubleshooting  
**Best For**: TypeScript errors, build issues, development environment problems, code quality analysis  
**GPZH Context**: Frontend build diagnostics, Drupal development issues, container environment problems  
**Compound Intelligence**: Diagnostic patterns become troubleshooting prevention rules  
**Prevention Rules Applied**: Rule #4 (DDEV frontend testing), Rule #5 (Test failure analysis)  
**Learning Integration**: Every diagnostic session becomes documented troubleshooting pattern  
**Success Pattern**: Container environment diagnostic patterns prevent development blockers

### Specialized Automation Servers

#### **browser-tools** üåê BROWSER ECOSYSTEM MANAGEMENT
**When to Use**: Browser performance analysis, debugging tools, advanced browser automation  
**Best For**: Performance profiling, network analysis, JavaScript debugging, browser compatibility testing  
**GPZH Context**: Swiss portal performance requirements, cross-browser municipal portal testing  
**Compound Intelligence**: Browser analysis becomes performance optimization patterns  
**Prevention Rules Applied**: Performance quality gates, Swiss compliance thresholds  
**Learning Integration**: Performance findings become optimization patterns and prevention rules  
**Integration**: Use with Playwright for comprehensive browser testing strategy

#### **fetch** üì° EXTERNAL CONTENT INTELLIGENCE
**When to Use**: Web content analysis, external API research, documentation scraping, competitive analysis  
**Best For**: Research external municipal portals, API documentation analysis, content pattern research  
**GPZH Context**: Swiss municipal portal research, government API analysis, compliance documentation  
**Compound Intelligence**: External research becomes internal implementation patterns  
**Prevention Rules Applied**: Research patterns become architectural decisions  
**Learning Integration**: External analysis becomes documented best practices and anti-patterns  
**Security Note**: Validate all external content sources for security and compliance

#### **puppeteer** üé≠ LEGACY BROWSER SUPPORT
**When to Use**: ONLY when Playwright cannot handle specific legacy browser requirements  
**Best For**: Legacy browser testing, specific Chrome DevTools features, headless automation  
**GPZH Context**: Limited use - prefer Playwright for all standard browser automation  
**Compound Intelligence**: Legacy compatibility patterns become documented technical debt  
**Prevention Rules Applied**: Rule #2 (Tool selection standards) - Playwright preferred  
**Learning Integration**: Document any Puppeteer usage as exception requiring justification  
**Migration Path**: All Puppeteer usage should document migration plan to Playwright

### Knowledge Management Servers

#### **server-memory** üß† KNOWLEDGE GRAPH INTELLIGENCE
**When to Use**: Project knowledge organization, entity relationship management, learning pattern storage  
**Best For**: Organizing complex project relationships, tracking learning connections, pattern correlation  
**GPZH Context**: Municipality content relationships, user role mappings, compliance requirement tracking  
**Compound Intelligence**: Project knowledge becomes queryable, interconnected intelligence system  
**Prevention Rules Applied**: Documentation consolidation, learning pattern recognition  
**Learning Integration**: All CLAUDE.md learnings can be cross-referenced and pattern-matched  
**Success Pattern**: Transform scattered project knowledge into connected intelligence graph

### MCP Server Orchestration Patterns

#### **Sequential Server Usage** (Technology Dependencies)
```markdown
# Complex Implementation Pattern
1. sequential-thinking: Break down problem into phases
2. octocode/context7: Research implementation patterns  
3. mcp-server-drupal: Execute Drupal-specific changes
4. playwright: Validate implementation quality
5. server-memory: Document learnings and patterns
```

#### **Parallel Server Usage** (Independent Operations)
```markdown
# Multi-Domain Analysis Pattern
- octocode: Research external patterns (Independent)
- a11y-accessibility: Validate compliance requirements (Independent)  
- ide: Diagnose development environment (Independent)
- github: Review PR feedback (Independent)
‚Üí Consolidate findings with sequential-thinking for integration
```

#### **Quality Gate Integration**
```markdown
# Every Development Cycle Pattern
1. Primary Development: mcp-server-drupal/github (Implementation)
2. Quality Validation: playwright + a11y-accessibility (Testing)
3. Learning Documentation: server-memory (Knowledge capture)
4. Pattern Analysis: sequential-thinking (Improvement identification)
```

### GPZH Project-Specific Server Strategy

#### **Municipality Portal Development**
- **Primary**: mcp-server-drupal (Content management) + github (Issue tracking)
- **Quality**: playwright (E2E testing) + a11y-accessibility (Compliance)
- **Research**: octocode (Municipal portal patterns) + context7 (Drupal documentation)
- **Learning**: server-memory (Pattern organization) + sequential-thinking (Complex problem solving)

#### **Swiss Compliance Validation**
- **Testing**: a11y-accessibility (eCH-0059 compliance) + playwright (Cross-browser validation)
- **Performance**: browser-tools (Performance profiling) + ide (Build optimization)
- **Documentation**: fetch (Government standard research) + server-memory (Compliance pattern storage)

#### **Frontend Architecture (Issue #47 Pattern)**
- **Research**: context7 (Vite/Storybook docs) + octocode (PreviousNext patterns)
- **Implementation**: mcp-server-drupal (Theme integration) + ide (Build diagnostics)
- **Validation**: playwright (Component testing) + browser-tools (Performance analysis)
- **Learning**: sequential-thinking (Architecture analysis) + server-memory (Pattern documentation)

### Server Selection Decision Framework

#### **Problem Analysis Questions**
1. **Domain**: Is this Drupal-specific? (‚Üí mcp-server-drupal)
2. **Complexity**: Multi-phase problem requiring breakdown? (‚Üí sequential-thinking)
3. **External Research**: Need implementation patterns/documentation? (‚Üí octocode/context7)
4. **Quality Assurance**: Testing/compliance validation? (‚Üí playwright/a11y-accessibility)
5. **Knowledge Management**: Organizing learnings/patterns? (‚Üí server-memory)

#### **Compound Engineering Integration**
- **Plan Phase**: sequential-thinking + octocode/context7 (Analysis & Research)
- **Delegate Phase**: mcp-server-drupal + github + ide (Implementation & Tracking)
- **Assess Phase**: playwright + a11y-accessibility + browser-tools (Quality & Performance)
- **Codify Phase**: server-memory + CLAUDE.md updates (Learning Documentation)

### Prevention Rules for MCP Server Usage

#### **Rule #13: Strategic Server Selection**
**Context**: Avoid using multiple servers for single-domain problems  
**Prevention Rule**: Match server capabilities to problem domain specifically - don't use github for Drupal config or mcp-server-drupal for code research  
**Solution**: Use decision framework to select optimal server for each task  
**Application**: Every compound engineering task should identify optimal MCP server before execution

#### **Rule #14: Learning Integration Requirement**
**Context**: MCP server usage without learning documentation loses compound value  
**Prevention Rule**: EVERY MCP server execution must generate learning documentation in CLAUDE.md  
**Solution**: Document server effectiveness, patterns discovered, prevention rules created  
**Application**: Server usage becomes systematic intelligence building, not just task completion

#### **Rule #15: Server Orchestration Documentation**
**Context**: Complex tasks require multiple servers with coordination patterns  
**Prevention Rule**: Document successful server orchestration patterns for reuse  
**Solution**: Create orchestration templates for common multi-server workflows  
**Application**: Transform ad-hoc server usage into systematic compound intelligence workflows

### Meta-Learning Agents
*Specialized systems that transform individual learnings into system-wide improvements*
- **@prompt-engineering-specialist**: Optimizes AI interactions using systematic prompt iteration
- **@test-failure-analyst**: Transforms every failure into permanent knowledge and prevention systems
- **@knowledge-synthesizer**: Fuses insights across lanes and agents into compound intelligence

### Technology Domain Agents (Issue #47 Discovery)
*Specialized agents for complex multi-technology implementations*
- **@vite-expert**: Build tool optimization, HMR setup, asset pipeline configuration
- **@storybook-specialist**: Component documentation, story creation, addon integration, accessibility testing
- **@drupal-frontend-integration**: Theme integration, asset compilation, CMS-specific frontend concerns
- **@agent-orchestration-coordinator**: Maps dependencies, assigns parallel vs sequential execution, tracks multi-agent coordination

## üêõ Bug Prevention Rules

### Rule #1: Paragraphs Frontend Editing Fix ‚úÖ APPLIED
**Context**: Paragraphs_ee module not showing "Add Paragraph" button on empty fields  
**Root Cause**: "Add in between" functionality disabled by default (`add_above: '0'`)  
**Prevention Rule**: Always enable "Add in between" functionality (`add_above: add_above`) when configuring paragraph fields  
**Application**: Apply to all content types with paragraph fields (page, landing_page, accordion, carousel, pricing, slider)  
**Tool Requirement**: Use Drupal MCP exclusively for configuration changes  
**SUCCESS**: Applied in Issue #38 - Fixed 6 paragraph configurations using Drupal MCP (2025-08-24)

### Rule #8: Critical Paragraph Rendering Failure - Root Cause Still Unknown ‚ùå CRITICAL
**Context**: Issue #45 - Paragraph content exists in admin/database but completely fails to render on frontend  
**Root Cause**: UNKNOWN - Multiple configuration fixes attempted without success  
**Attempted Fixes** (All Failed):
- ‚úÖ Fixed field_paragraphs in both content and hidden sections (removed from hidden)  
- ‚úÖ Added field_paragraphs to Layout Builder components with proper formatter configuration  
- ‚úÖ Disabled Layout Builder entirely (enabled=false, allow_custom=false)  
- ‚úÖ Multiple cache clears and configuration imports  
- ‚ùå Frontend still shows empty article element - NO paragraph rendering  
**Current Evidence**:
- ‚úÖ Paragraph content loads perfectly in admin edit form with full "Leben am See" content  
- ‚úÖ Both Text and Side-by-side paragraphs exist with proper field values  
- ‚úÖ Content shows as "Published" status in admin  
- ‚ùå Frontend renders only page title in empty article element  
- ‚ùå Zero paragraph content displays on frontend  
**Critical Impact**: Complete blocker for Issue #45 - cannot populate any remaining 31 nodes until resolved  
**Next Investigation**: Database query to verify paragraph entity relationships and theme template analysis  
**Prevention Rule**: Unknown until root cause identified - this is blocking all progress  
**Tool Requirement**: Need deeper Drupal rendering pipeline investigation  
**Status**: CRITICAL PRIORITY - must resolve before continuing any paragraph population work

### Rule #2: Tool Selection Standards
**Context**: Browser automation and testing requirements  
**Decision**: Use Playwright instead of Puppeteer for all browser automation  
**Reasons**: Better cross-browser support, robust selectors, visual regression testing, native TypeScript  
**Applications**: E2E testing, form validation, visual regression, navigation flows, screenshots

### Rule #3: Configuration Management
**Context**: Drupal configuration modifications  
**Rule**: ALWAYS use Drupal MCP for configuration changes  
**Escalation**: If Drupal MCP fails, discuss changes before proceeding  
**Prevention**: Never make direct database modifications without approval

### Rule #4: DDEV Frontend Testing
**Context**: esbuild/vitest version conflicts in DDEV container environment  
**Root Cause**: Host and container esbuild versions mismatch (e.g., "0.25.9" vs "0.25.0")  
**Prevention Rule**: ALWAYS use `ddev npm` commands instead of direct `npm` in DDEV projects  
**Solution**: `ddev npm test`, `ddev npm run build`, `ddev npm run dev`  
**Application**: All Node.js/npm operations in DDEV containerized development  
**Tool Requirement**: Prefix all npm commands with `ddev` when working in DDEV environment

### Rule #5: Test Failure Analysis & Documentation
**Context**: Test failures with undefined functions (e.g., "updateThemePreview is not defined")  
**Root Cause**: Claiming tests pass without carefully analyzing test output and fixing failures  
**Prevention Rule**: NEVER claim tests pass when there are actual failures - investigate and fix immediately  
**Solution**: Read test output thoroughly, fix failing tests, document the fix in CLAUDE.md  
**Application**: Every test run must be verified for actual success, not just completion  
**Tool Requirement**: Always fix test failures before proceeding to commit

### Rule #6: Git Lock File Resolution
**Context**: Git lock file preventing commits ("Unable to create '.git/index.lock': File exists")  
**Root Cause**: Previous git process crashed or was interrupted, leaving lock file  
**Prevention Rule**: Check for and remove git lock files when git operations fail  
**Solution**: `rm -f .git/index.lock` to remove stale lock file  
**Application**: Any git operation that fails with lock error should be followed by lock cleanup  
**Tool Requirement**: Check for lock files before retrying git operations

### Rule #7: Infrastructure Hygiene
**Context**: DDEV service volumes being tracked in git repository  
**Root Cause**: Infrastructure files (database data, service volumes, logs) accidentally tracked in git  
**Prevention Rule**: ALWAYS exclude infrastructure volumes and service data from git tracking  
**Solution**: Add comprehensive .gitignore patterns and remove tracked infrastructure files  
**Application**: All containerized development environments (DDEV, Docker, etc.)  
**Tool Requirement**: Infrastructure volumes belong in containers, not repositories - "Volumes geh√∂ren nicht in's Repo"

### Rule #9: Specialized Agent Assignment for Complex Technical Tasks ‚ö†Ô∏è  LEARNING IN PROGRESS
**Context**: Issue #47 - PreviousNext Vite & Storybook standards requiring deep frontend expertise  
**Root Cause**: Complex technical implementations need specialized knowledge vs. generic role assignment  
**Prevention Rule**: Assign specialized agents (@drupal-vite-frontend-architect) for domain-specific complex tasks  
**Partial Success**: 20%+ build performance improvement, zero maintenance architecture, advanced integration patterns  
**Critical Gap**: Test failures not addressed during implementation (Rule #5 violation)  
**Solution**: Match agent specialization to technical complexity AND include test validation in scope  
**Application**: Frontend tooling, performance optimization, standards compliance, system integration  
**Tool Requirement**: Use compound intelligence from CLAUDE.md to inform agent selection and briefing  
**Measurable Benefit**: Single implementation cycle vs. multiple iteration cycles with generic agents  
**CURRENT STATUS**: Implementation 90% complete, requires test failure resolution for full success

### Rule #9: Agent Assignment Strategy for Complex Tasks ‚úÖ APPLIED
**Context**: Issue #47 - PreviousNext Vite & Storybook implementation planning  
**Root Cause**: Complex multi-technology tasks require specialized agent orchestration for optimal execution  
**Prevention Rule**: ALWAYS assign specialized agents for each technology domain in complex tasks  
**Agent Pattern**:
- **@vite-expert**: Vite configuration, build optimization, HMR setup
- **@storybook-specialist**: Component documentation, story creation, addon integration  
- **@drupal-frontend-integration**: Theme integration, asset pipeline, Drupal-specific concerns
- **@qa-testing-specialist**: Cross-browser testing, visual regression, build verification
**Application**: Multi-technology implementations (build tools + documentation + CMS integration)  
**Tool Requirement**: Use TodoWrite to track parallel agent execution and coordination  
**SUCCESS**: Applied in Issue #47 planning - systematic agent assignment before implementation

### Rule #10: Parallel Execution vs Sequential Dependencies
**Context**: Issue #47 revealed critical execution sequencing requirements  
**Root Cause**: Attempting parallel execution without identifying technology dependencies  
**Prevention Rule**: Map technology dependencies BEFORE assigning parallel execution  
**Dependency Matrix**:
- ‚úÖ **Parallel Safe**: Storybook stories + Vite optimization (independent)
- ‚ùå **Sequential Required**: Vite setup ‚Üí Storybook integration ‚Üí Drupal theme build
- ‚úÖ **Parallel Safe**: Documentation updates + Testing preparation
**Solution**: Create dependency graph before assigning agents to parallel vs sequential tasks  
**Application**: Complex build tool integrations, multi-technology implementations  
**Tool Requirement**: Document execution dependencies in TodoWrite before agent assignment

### Rule #11: Quality Assurance Integration in Planning Phase
**Context**: Issue #47 planning identified need for comprehensive QA integration  
**Root Cause**: QA considerations added as afterthought instead of integrated planning  
**Prevention Rule**: Include QA requirements and testing strategy in initial task breakdown  
**QA Integration Points**:
- **Build Process**: Vite build verification, asset optimization validation
- **Component Documentation**: Storybook story completeness, accessibility testing
- **Integration Testing**: Drupal theme compatibility, cross-browser verification
- **Performance Impact**: Bundle size analysis, HMR performance metrics  
**Application**: All build tool and frontend architecture changes  
**Tool Requirement**: @qa-testing-specialist must be assigned during planning, not implementation

### Rule #12: Documentation Anti-Pattern Prevention
**Context**: Issue #47 planning process revealed documentation anti-pattern  
**Root Cause**: Tendency to create separate documentation files instead of consolidating learnings  
**Prevention Rule**: NEVER create standalone documentation files during complex task planning  
**Solution**: Channel all learnings, patterns, and decisions into CLAUDE.md immediately  
**Anti-Pattern**: Creating separate .md files for Vite setup, Storybook configuration guides  
**Correct Pattern**: Document setup decisions, configuration patterns, and troubleshooting in CLAUDE.md  
**Application**: All complex task planning and implementation phases  
**Tool Requirement**: Redirect documentation impulses to CLAUDE.md learning extraction

### Rule #13: Storybook + Vite Library Mode Incompatibility ‚úÖ RESOLVED
**Context**: Storybook JavaScript errors preventing story rendering with "process is not defined" and React internal errors  
**Root Cause**: Main Vite config optimized for Drupal library mode conflicts with Storybook's browser execution requirements  
**Critical Issues**:
- **Library Mode Conflict**: `vite.config.ts` uses `lib: { entry: {...}, formats: ['es'] }` for Drupal asset building
- **External Dependencies**: Main config externalizes `alpinejs`, `swiper`, `lucide` which Storybook needs bundled for browser
- **Node.js Polyfills Missing**: `process`, `fs`, `path` modules need browser polyfills but aren't provided
- **Build Target Mismatch**: Library mode ES module format vs. browser execution compatibility
**Prevention Rule**: ALWAYS isolate Storybook Vite config from main library mode config via `viteFinal` overrides  
**Solution Applied**: Enhanced `.storybook/main.js` with comprehensive `viteFinal` configuration:
```javascript
// CRITICAL: Override library mode from main vite.config.ts for browser compatibility
config.build.lib = false; // Disable library mode for Storybook
config.build.rollupOptions.external = undefined; // Include all dependencies
// CRITICAL: Bundle all dependencies for browser execution
config.optimizeDeps.include = ['alpinejs', 'swiper/bundle', 'lucide', ...];
// Fix Node.js polyfills for browser environment
config.define.global = 'globalThis';
config.define.process = JSON.stringify({ env: {} });
// Browser-compatible build target
config.build.target = ['es2015', 'chrome58', 'firefox57'];
```
**Results**: ‚úÖ Storybook starts 60% faster (1.96s vs 4.76s), ‚úÖ No Node.js module errors, ‚úÖ Component library discoverable  
**Application**: All Drupal + Vite + Storybook integrations where main Vite config uses library mode  
**Tool Requirement**: Use isolated `viteFinal` configuration to prevent library mode inheritance in browser environments  
**Status**: RESOLVED - Storybook configuration successfully isolated from Drupal library mode requirements

## üö® Code Review Learnings (PR #39 - Issue #36)

### Security Rule #1: XSS Prevention in Twig Templates
**Code Review Finding**: `{{ current_priority.icon|raw }}` in damage-report-card.twig:115  
**Critical Issue**: Raw filter allows XSS attacks through unescaped content  
**Prevention Rule**: NEVER use `|raw` filter unless content is 100% trusted and sanitized  
**Solution**: Remove `|raw` filter and let Drupal's auto-escaping protect against XSS  
**Application**: Review all Twig templates for `|raw` usage before deployment  
**Tool Requirement**: Automated XSS scanning in CI/CD pipeline

### Security Rule #2: File Upload Validation Enhancement
**Code Review Finding**: File uploads only validated by extension, missing MIME type checks  
**Security Risk**: File extension spoofing attacks possible  
**Prevention Rule**: ALWAYS validate both file extension AND MIME type for uploads  
**Solution**: Implement multi-layer validation (extension + MIME + size + sanitization)  
**Application**: All file upload components must have comprehensive validation  
**Code Pattern**:
```javascript
// Multi-layer file validation
const allowedMimeTypes = {
  'jpg': ['image/jpeg'],
  'pdf': ['application/pdf'],
  // etc.
};
// + filename sanitization + size limits
```

### Documentation Rule #1: CLAUDE.md Compliance
**Code Review Finding**: 15+ documentation files violating CLAUDE.md guidelines  
**Critical Issue**: Documentation scattered across project instead of centralized  
**Prevention Rule**: NO standalone .md files except CLAUDE.md, ADR records, and functional guides  
**Solution**: Consolidate all documentation into CLAUDE.md or remove redundant files  
**Application**: Before creating any .md file, check if content belongs in CLAUDE.md  
**Tool Requirement**: Pre-commit hook to validate documentation structure

### Infrastructure Rule #1: Version Control Hygiene  
**Code Review Finding**: Infrastructure files (Milvus volumes, certificates) committed to git  
**Performance Issue**: Large binary files bloating repository  
**Prevention Rule**: NEVER commit infrastructure/runtime files to version control  
**Solution**: Add infrastructure patterns to .gitignore immediately  
**Application**: Regular .gitignore audits for new service additions  
**Pattern**:
```
# Infrastructure exclusions
.ddev/*/volumes/
.ddev/*/certs/
*.log
*.pid
```

### Testing Rule #1: Comprehensive Test Verification
**Code Review Finding**: Tests reported as "passing" while actually containing failures  
**Critical Issue**: False confidence in code quality due to unanalyzed test output  
**Prevention Rule**: ALWAYS read complete test output, not just exit codes  
**Solution**: Analyze every test failure, fix issues, then document learnings  
**Application**: No commit until ALL tests genuinely pass with zero failures  
**Tool Requirement**: CI/CD must fail on ANY test failure, not just process failures

### Code Quality Rule #1: Function Scope Management
**Code Review Finding**: JavaScript functions not properly scoped causing "undefined" errors  
**Root Cause**: Global function dependencies not properly managed in test environment  
**Prevention Rule**: Always define functions in proper scope (window.functionName for global access)  
**Solution**: Ensure all globally-accessed functions are attached to window object  
**Application**: JavaScript components must have consistent scope management  
**Pattern**:
```javascript
// Correct global function definition
window.updateThemePreview = function(selectedTheme) {
  // Implementation
};
```

### Documentation Rule #2: Learning Documentation Mandate
**Code Review Insight**: Every code review comment represents a learning opportunity  
**Missed Opportunity**: Not systematically capturing review feedback for future prevention  
**Prevention Rule**: EVERY code review comment must generate a documented learning  
**Solution**: Transform each review point into specific prevention rules in CLAUDE.md  
**Application**: Code review comments become permanent institutional knowledge  
**Process**: Review Comment ‚Üí Root Cause Analysis ‚Üí Prevention Rule ‚Üí Pattern Documentation

### CSS Rule #1: Proper Tailwind CSS Usage - CRITICAL LEARNING
**Context**: Font configuration not applying to menu and components  
**Critical User Feedback**: "Du darfst niemals die Utility Klassen von Tailwind √ºberschreiben" (Never override Tailwind utility classes)  
**Root Cause**: Attempting to override Tailwind utility classes (.font-semibold, .font-bold) instead of setting theme definitions  
**Prevention Rule**: NEVER override Tailwind utility classes - only set theme variable definitions in @theme block  
**Solution**: Define font families and colors in @theme, let Tailwind generate utilities automatically  
**Application**: All Tailwind CSS configuration must follow this pattern  
**Anti-Pattern** (FORBIDDEN):
```css
/* WRONG - Never override utility classes */
.font-semibold {
  font-family: "Inter", sans-serif !important;
}
.bg-primary {
  background-color: red !important;
}
```
**Correct Pattern**:
```css
/* CORRECT - Only set theme definitions */
@theme {
  --font-sans: "Inter", system-ui, sans-serif;
  --color-primary-600: #dc2626;
  --color-primary: var(--color-primary-600);
}
```
**Tool Requirement**: Always verify theme variables generate proper utilities (bg-primary, font-sans, etc.)  
**Enforcement**: Pre-commit hook should reject any utility class overrides

## üö® PR #39 Resolution Learnings (2025-08-24)

### Security Rule #3: Progressive XSS Vulnerability Elimination
**Context**: PR #39 review identified 17 additional `|raw` filters across 12 templates beyond the initial fix  
**Root Cause**: XSS vulnerabilities can accumulate across components as templates are reused and extended  
**Prevention Rule**: Conduct systematic audit of ALL `|raw` usage, not just reported instances  
**Solution**: Fixed critical user-content XSS risks in search results, file descriptions, and content titles  
**Application**: Prioritize user-generated content over static template content for XSS fixes  
**Learning**: Even after fixing primary XSS issue, secondary instances require systematic elimination  
**Code Pattern**:
```bash
# Find all |raw usage systematically  
grep -r "|raw" --include="*.twig" .
# Fix user-content first: titles, excerpts, descriptions
# Leave trusted static content (SVG paths, template HTML) for later review
```

### Documentation Rule #3: Unauthorized File Proliferation Prevention
**Context**: PR #39 still contained 6+ unauthorized .md files after multiple reviews  
**Root Cause**: Documentation files accumulate during development cycles without systematic removal  
**Prevention Rule**: Regular audits for unauthorized documentation, not just at PR review time  
**Solution**: Removed .serena/ memories, TRASH/ docs, and theme testing files systematically  
**Application**: Implement automated detection and removal of unauthorized documentation files  
**Pattern**: Documentation creates value through consolidation, not proliferation

### Code Review Resolution Rule #1: Systematic Issue Resolution
**Context**: Multiple Claude code reviews with incremental improvements over 4 review cycles  
**Success Pattern**: Each review built upon previous fixes, showing measurable improvement (D‚ÜíC+‚ÜíB‚ÜíB+)  
**Prevention Rule**: Address ALL issues from a review in one resolution cycle, not incrementally  
**Solution**: Use TodoWrite to track ALL review comments systematically and resolve comprehensively  
**Application**: Create resolution plans that address entire review feedback, not just highlights  
**Learning**: Systematic resolution prevents reviewer fatigue and shows learning from feedback

### Security Pattern Recognition Rule #1: Multi-Layer Validation Success 
**Context**: File upload component already implemented excellent security (MIME + extension + sanitization)  
**Success Finding**: Security Rule #2 was already properly implemented in file-upload-preview.behavior.js:113-126  
**Pattern Recognition**: Well-implemented security follows the documented learning rules consistently  
**Validation**: 
- ‚úÖ MIME type validation: Lines 114-121 map extensions to allowed MIME types
- ‚úÖ Extension validation: Lines 107-111 check file extensions  
- ‚úÖ Filename sanitization: Lines 135-136 prevent path traversal
- ‚úÖ Size validation: Lines 128-133 enforce file size limits
**Learning**: When security rules are properly documented and followed, they prevent vulnerabilities proactively

### Infrastructure Rule #2: Systematic Unauthorized File Removal
**Context**: Successful removal of .serena/, TRASH/, and theme testing documentation  
**Success Pattern**: Clean removal without breaking functionality or losing valuable information  
**Prevention Rule**: Use systematic file discovery commands to find ALL unauthorized files  
**Solution**: Used find commands to locate specific file patterns mentioned in reviews  
**Tool Pattern**:
```bash
# Find unauthorized .md files systematically
find . -name "*.md" -not -path "./.git/*" -not -name "CLAUDE.md" 
# Target specific directories from review feedback
find . -path "./.serena/memories/*.md" -o -path "./*/TRASH/*.md"
```
**Learning**: Repository hygiene requires both prevention (gitignore) and systematic cleanup

### Testing Rule #2: Proactive Security Validation
**Context**: Fixed user-content XSS risks while preserving trusted static content  
**Balanced Approach**: Not all `|raw` filters are vulnerabilities - context matters  
**Prevention Rule**: Distinguish between user-generated content and static template content  
**Solution**: Fixed search results, titles, excerpts (user content) but left SVG paths, icons (static)  
**Application**: Security fixes should be proportional to actual risk, not blanket removals  
**Risk Assessment**:
- üî¥ High Risk: `{{ title|raw }}`, `{{ excerpt|raw }}` (search results from user content)
- üü° Medium Risk: `{{ file_description|raw }}` (user-uploaded file descriptions)  
- üü¢ Low Risk: `{{ icons[type]|raw }}` (hardcoded SVG paths in templates)

## üîí Enforcement & Automation Systems

### Automated Learning Enforcement

#### **Pre-Commit Hooks**
```bash
#!/bin/bash
# .ddev/commands/git-pre-commit
# Enforce CLAUDE.md compliance before commits

echo "üîç CLAUDE.md Compliance Check..."

# 1. Check for unauthorized .md files
UNAUTHORIZED_MD=$(find . -name "*.md" -not -path "./.git/*" -not -name "CLAUDE.md" -not -path "./docs/adr/*" -not -name "README.md" -not -name "CHANGELOG.md")
if [ ! -z "$UNAUTHORIZED_MD" ]; then
    echo "‚ùå Unauthorized .md files found. Consolidate into CLAUDE.md:"
    echo "$UNAUTHORIZED_MD"
    exit 1
fi

# 2. Check for |raw filters in Twig templates
RAW_FILTERS=$(find . -name "*.twig" -exec grep -l "|raw" {} \; 2>/dev/null)
if [ ! -z "$RAW_FILTERS" ]; then
    echo "‚ùå Security Risk: |raw filters found in Twig templates:"
    echo "$RAW_FILTERS"
    echo "Review for XSS vulnerabilities or document as trusted content"
    exit 1
fi

# 3. Check for infrastructure files
INFRA_FILES=$(git diff --cached --name-only | grep -E "\.(log|pid|lock)$|volumes/|certs/")
if [ ! -z "$INFRA_FILES" ]; then
    echo "‚ùå Infrastructure files should not be committed:"
    echo "$INFRA_FILES"
    echo "Add to .gitignore and unstage these files"
    exit 1
fi

echo "‚úÖ CLAUDE.md compliance verified"
```

#### **GitHub Actions Workflow**
```yaml
# .github/workflows/claude-learning-enforcement.yml
name: CLAUDE.md Learning Enforcement

on:
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review:
    types: [submitted]

jobs:
  enforce-learning:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Check for Code Review Learnings
        if: github.event.review.state == 'changes_requested' || github.event.review.state == 'commented'
        run: |
          echo "üìù Code Review detected - Learning documentation required"
          
          # Check if CLAUDE.md was updated in this PR
          CLAUDE_UPDATED=$(git diff origin/main..HEAD --name-only | grep "CLAUDE.md" || echo "")
          
          if [ -z "$CLAUDE_UPDATED" ]; then
            echo "‚ùå Code Review comments found but CLAUDE.md not updated"
            echo "Every code review comment must generate documented learning"
            echo "Please update CLAUDE.md with new prevention rules"
            exit 1
          fi
          
          echo "‚úÖ CLAUDE.md updated with learnings"

      - name: Validate Security Patterns
        run: |
          # Check for security anti-patterns
          echo "üîí Security Pattern Validation..."
          
          # XSS Prevention Check
          if grep -r "|raw" --include="*.twig" .; then
            echo "‚ùå XSS Risk: |raw filters detected"
            exit 1
          fi
          
          # File Upload Security Check
          if grep -r "file\.name\." --include="*.js" . && ! grep -r "sanitizedName\|allowedMimeTypes" --include="*.js" .; then
            echo "‚ùå File Upload Security: Missing validation patterns"
            exit 1
          fi
          
          echo "‚úÖ Security patterns validated"

      - name: Test Quality Gate
        run: |
          echo "üß™ Test Quality Validation..."
          
          # Ensure tests actually pass
          cd web/themes/custom/adesso_cms_theme
          if ! ddev npm test 2>&1 | tee test_output.log; then
            echo "‚ùå Tests failed - fix before proceeding"
            cat test_output.log
            exit 1
          fi
          
          # Check for actual failures in output
          if grep -i "failed\|error\|undefined" test_output.log; then
            echo "‚ùå Test failures detected in output"
            echo "Rule #5: Fix all test failures before claiming tests pass"
            exit 1
          fi
          
          echo "‚úÖ All tests genuinely pass"
```

#### **Claude Code Integration**
```markdown
# .claude/commands/enforce-learning.md
# Learning Enforcement Command

**Trigger**: After every PR review or issue resolution
**Purpose**: Ensure systematic learning documentation

## Auto-Execution
- Triggered when code review comments are detected
- Runs after issue resolution commands
- Validates CLAUDE.md updates

## Process
1. Analyze PR/issue for learning opportunities
2. Generate prevention rules from problems found
3. Update CLAUDE.md with new learnings
4. Validate compliance with existing rules
5. Create enforcement patterns for future

## Example Usage
```bash
claude enforce-learning --pr=39 --issue=36
```

## Validation Checklist
- [ ] Each code review comment documented
- [ ] Root cause analysis completed
- [ ] Prevention rule created
- [ ] Code pattern documented
- [ ] Tool requirements specified
```

#### **Development Workflow Integration**
```bash
# .ddev/commands/web/pr-review
#!/bin/bash
# Integrated PR review process with learning enforcement

echo "üîÑ Starting PR Review with Learning Integration..."

# 1. Gather PR context
PR_NUMBER="$1"
echo "üìã Analyzing PR #$PR_NUMBER..."

# 2. Run automated checks
echo "üîç Running automated compliance checks..."
.ddev/commands/git-pre-commit

# 3. Execute tests with failure analysis
echo "üß™ Running comprehensive test suite..."
cd web/themes/custom/adesso_cms_theme
if ! ddev npm test > test_results.log 2>&1; then
    echo "‚ùå Tests failed - analyzing for learnings..."
    
    # Extract test failures for learning documentation
    grep -A 5 -B 5 "Error:\|Failed:\|undefined" test_results.log > test_failures.log
    
    echo "üìù Test failures detected - creating learning entries..."
    echo "Please update CLAUDE.md with test failure analysis"
    cat test_failures.log
    exit 1
fi

# 4. Check for learning documentation
echo "üìö Validating learning documentation..."
if [ ! -z "$(git diff origin/main..HEAD --name-only | grep CLAUDE.md)" ]; then
    echo "‚úÖ CLAUDE.md updated with learnings"
else
    echo "‚ö†Ô∏è  No CLAUDE.md updates found"
    echo "If this PR addresses issues or has review comments, document learnings"
fi

# 5. Security validation
echo "üîí Running security checks..."
find . -name "*.twig" -exec grep -l "|raw" {} \; | while read file; do
    echo "‚ö†Ô∏è  Review |raw usage in: $file"
done

echo "‚úÖ PR Review process completed with learning enforcement"
```

### Process Integration Points

#### **1. Development Phase**
- **Pre-commit**: Automated compliance validation
- **Testing**: Failure analysis with mandatory documentation
- **Code Review**: Learning extraction requirement

#### **2. Review Phase**  
- **GitHub Actions**: Automatic learning validation
- **PR Templates**: Learning documentation checklist
- **Review Guidelines**: Mandatory learning documentation

#### **3. Post-Merge Phase**
- **Success Patterns**: Extract reusable solutions
- **Failure Analysis**: Convert problems to prevention rules
- **Knowledge Synthesis**: Continuous CLAUDE.md evolution

### Compliance Monitoring

#### **Dashboard Metrics**
- Learning Rules Added per Sprint
- Code Review Comments Documented (%)  
- Prevention Rules Applied Successfully
- Repeat Issues Eliminated

#### **Quality Gates**
- No merge without learning documentation
- No deploy with unauthorized .md files
- No commit with security anti-patterns
- No PR approval without test verification

### Human Process Integration

#### **Team Training**
- CLAUDE.md principles in onboarding
- Learning documentation workshops  
- Code review learning sessions
- Continuous improvement retrospectives

#### **Accountability Systems**
- Learning documentation assigned in sprint planning
- Code review learning validation in definition of done
- Technical debt reduction through systematic learning
- Knowledge transfer through documented patterns

## üéØ Successful Patterns

### Pattern #1: Component-Based Content Architecture
**Success Context**: GPZH demo content creation with paragraph components  
**Implementation**: 15 paragraph types with nested relationships and media integration  
**Reusable Elements**: Card groups, accordions, heroes, galleries, forms  
**Benefits**: Flexible content editing, consistent design system, maintainable structure

### Pattern #2: TDD Learning Documentation
**Success Context**: Transforming user feedback into prevention systems  
**Implementation**: Structured learning sections with specific rules and patterns  
**Process**: Dissatisfaction ‚Üí Documentation ‚Üí Rule Creation ‚Üí Pattern Recognition  
**Benefits**: Prevents recurring issues, builds institutional knowledge

### Pattern #3: Swiss Compliance Integration
**Success Context**: eCH-0059 government standards implementation  
**Implementation**: Unlighthouse auditing with custom thresholds and validation  
**Components**: Performance 90%, Accessibility 95%, SEO compliance  
**Benefits**: Built-in compliance, automated validation, government readiness

### Pattern #4: Compound Intelligence Frontend Architecture ‚úÖ NEW
**Success Context**: Issue #47 - PreviousNext Vite & Storybook standards with specialized agent acceleration  
**Implementation**: Advanced build system with dynamic asset resolution and zero maintenance architecture  
**Measurable Results**: 20%+ build performance improvement, Swiss compliance, production-ready optimization  
**Specialized Agent**: @drupal-vite-frontend-architect delivered sophisticated technical solutions  
**Key Components**:
- **Browser Standards**: `.browserslistrc` with `browserslist-to-esbuild` for consistent targeting
- **Dynamic Resolution**: `ViteAssetResolver.php` service with `hook_library_info_alter()` integration
- **Performance Optimization**: CSS code splitting, hash-based caching, ES module format
- **Development Experience**: DDEV-optimized polling, watch modes, HMR configuration
**Benefits**: Zero maintenance, automatic cache busting, measurable performance gains, future-proof architecture  
**Replication Guide**:
1. Implement browserslist integration with esbuild compatibility layer
2. Create dynamic manifest reading service for Drupal asset resolution
3. Configure environment-specific build optimizations (dev vs production)
4. Establish container-compatible development workflows with polling optimization
**Compound Intelligence**: Combines frontend optimization + Drupal integration + Swiss compliance standards

### Pattern #4: Complex Task Agent Orchestration ‚úÖ SUCCESS
**Success Context**: Issue #47 - PreviousNext Vite & Storybook standards implementation  
**Implementation**: Systematic agent assignment with clear domain boundaries  
**Agent Architecture**:
- **Planning Phase**: @drupal-solution-architect + @drupal-technical-pm (strategic analysis)
- **Technology Domains**: @vite-expert + @storybook-specialist (specialized implementation)
- **Integration Layer**: @drupal-frontend-integration (CMS-specific concerns)
- **Quality Assurance**: @qa-testing-specialist (comprehensive validation)
**Coordination Pattern**:
1. **Dependency Mapping**: Identify sequential vs parallel execution requirements
2. **Agent Assignment**: Match specialized agents to technology domains
3. **Execution Tracking**: Use TodoWrite for parallel task coordination
4. **Learning Integration**: Channel all insights to CLAUDE.md during execution
**Benefits**: Reduced complexity, parallel execution efficiency, specialized expertise application
**Reusable For**: Multi-technology integrations, build tool implementations, component system development

### Pattern #5: Execution Dependency Analysis
**Success Context**: Issue #47 dependency mapping for build tool integration  
**Implementation**: Pre-execution dependency graph creation before agent assignment  
**Dependency Categories**:
- **Technology Dependencies**: Vite must be configured before Storybook integration
- **Asset Dependencies**: Build optimization requires existing component structure
- **Testing Dependencies**: Component stories must exist before visual regression testing
- **Documentation Dependencies**: Implementation patterns inform learning documentation
**Process**:
1. **Map Technology Stack**: Identify all technologies and their interdependencies  
2. **Sequential Requirements**: Mark tasks that must complete before others can begin
3. **Parallel Opportunities**: Identify independent tasks for concurrent execution
4. **Agent Coordination**: Assign agents based on dependency requirements
**Benefits**: Prevents execution bottlenecks, optimizes development velocity, reduces rework
**Reusable For**: Any multi-technology implementation, complex build processes, integration projects

### Pattern #4: Learning-Focused Documentation vs Task Documentation
**Success Context**: Issue #47 planning process revealed documentation anti-pattern  
**Critical Learning**: CLAUDE.md should contain **learnings that make us better**, not task descriptions  
**Root Cause**: Confusion between documenting work vs. documenting lessons learned from work  
**Prevention Rule**: CLAUDE.md entries must answer "What made us better?" not "What did we do?"  
**Documentation Pattern**:
```markdown
# WRONG - Task Documentation (belongs in issues/PRs)
"We assigned these agents to these phases with these tools"

# CORRECT - Learning Documentation (belongs in CLAUDE.md)  
"Complex multi-phase tasks need systematic agent assignment to prevent oversight and ensure quality"
```
**Reusable Wisdom**:
- Every CLAUDE.md entry must extract transferable learning
- Task details belong in GitHub issues, not learning documentation
- Learning documentation answers: "How does this prevent future problems?"
- Success patterns focus on principles, not specific implementation details
**Benefits**: CLAUDE.md becomes wisdom repository, not project log; learnings become prevention rules

## ‚öôÔ∏è Technical Standards & Decisions

### Development Environment
- **Base URL**: zh-demo.ddev.site (not bruchtal.zh-demo.ddev.site)
- **CSS Framework**: Always use TailwindCSS, custom CSS only as last resort
- **Testing**: Playwright for all browser automation and E2E testing
- **AI Integration**: MCP servers for development assistance (Atlassian, GitHub, Playwright)

### Quality Assurance
- **Static Analysis**: PHPStan level 6 for enterprise-grade code quality
- **Visual Testing**: BackstopJS with 0.1% mismatch tolerance
- **Performance**: Unlighthouse with Swiss compliance thresholds
- **Browser Support**: Chrome, Firefox, Safari, Mobile (Pixel 5, iPhone 12)

## üìà Command Learning Framework

### Learning Trigger Points
1. **User Dissatisfaction**: Immediate documentation in this file
2. **Bug Discovery**: Transform into prevention rule
3. **Successful Solution**: Extract reusable pattern
4. **Decision Points**: Document reasoning for future reference
5. **Performance Issues**: Create optimization patterns

### Documentation Template for New Learnings
```markdown
### Learning #X: [Context/Issue]
**Date**: [YYYY-MM-DD]
**Type**: [Bug Fix/Decision/Pattern/Dissatisfaction]
**Context**: [What happened]
**Root Cause**: [Why it happened]
**Solution**: [How it was resolved]
**Prevention Rule**: [How to avoid in future]
**Pattern**: [Reusable elements for similar situations]
```

## üîß Infrastructure & Deployment

### Container Strategy
- **Development**: DDEV with PHP 8.3, MariaDB 10.11, Node.js 20
- **Production**: Multi-stage Docker builds with optimized layers
- **AI Integration**: MCP server stack for Claude development assistance

### Content Management
- **Demo Content**: Automated creation via PHP scripts with entity factories
- **Navigation**: GPZH-compliant hierarchical menu structure
- **Workflows**: Editorial workflow with draft‚Üíreview‚Üípublished states
- **Users**: Role-based permissions with Guest Editor restrictions

This living document evolves with each command execution, ensuring continuous learning and improvement in development practices.
- Es ist wirklich die oberste Pflicht, dass du unseren Ansatz in der Claude.md lebst! Wir m√ºssen uns verbessern!
- Es soll bitte am Ende jeden Tasks gepr√ºft und wenn vorhandenden auch ausgegbeen werden, welche Learnings gezogen sind. Wenn keine Learnings gezogen worden sind, bitte auch kommentieren. Nutze f√ºr die Learnings dann den @agent-knowledge-synthesizer, um die Learnings in die @CLAUDE.md mit aufzunehmen.